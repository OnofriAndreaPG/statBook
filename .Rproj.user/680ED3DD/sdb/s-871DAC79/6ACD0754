{
    "collab_server" : "",
    "contents" : "\"DRCweibull.1\" <-\nfunction(fixed = c(NA, NA, NA), names = c(\"a\", \"b\", \"c\"))\n{\n    ## Checking arguments\n    numParm <- 3\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        a <- parmMat[, 1]; b <- parmMat[, 2]; c <- parmMat[, 3]\n        a * exp ( - exp ( b - c * log(x + 0.000001)))\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n\n        a <- max(y) * 1.05\n\n          ## Linear regression on pseudo y values\n          pseudoY <- log( - log( y / a ) )\n          coefs <- coef( lm(pseudoY ~ log(x+0.000001)) )\n\n          b <- coefs[1]\n          c <- - coefs[2]\n\n        return(c(a, b, c)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Weibull type I\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"DRCweibull.2\" <-\nfunction(fixed = c(NA, NA, NA), names = c(\"a\", \"b\", \"c\"))\n{\n    ## Checking arguments\n    numParm <- 3\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        a <- parmMat[, 1]; b <- parmMat[, 2]; c <- parmMat[, 3]\n        a * (1 - exp( - exp (b - c * log(x+0.0000001))))\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n\n        a <- max(y) * 1.05\n\n          ## Linear regression on pseudo y values\n          pseudoY <- log( - log( (a - y ) / a ) )\n          coefs <- coef( lm(pseudoY ~ log(x+0.0000001)) )\n\n          k <- coefs[1]\n          c <- - coefs[2]\n          b <- k\n\n        return(c(a, b, c)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Weibull type II\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n######################################################################\n\"L.2\" <-\nfunction (upper = 1, fixed = c(NA, NA), names = c(\"b\", \"e\"))\n{\n  numParm <- 2\n  if (!is.character(names) | !(length(names) == numParm)) {\n    stop(\"Not correct 'names' argument\")\n  }\n  if (!(length(fixed) == numParm)) {\n    stop(\"Not correct length of 'fixed' argument\")\n  }\n  return(logistic(fixed = c(fixed[1], 0, upper, fixed[2], 1),\n                  names = c(names[1], \"c\", \"d\", names[2], \"f\"),\n                  fctName = as.character(match.call()[[1]]),\n                  fctText = \"Logistic (ED50 as parameter)\"))\n}\n\n######################################################################\nl10normal <- function (fixed = c(NA, NA, NA, NA), names = c(\"b\", \"c\", \"d\", \"e\"), method = c(\"1\", \"2\", \"3\", \"4\"), ssfct = NULL, fctName,\n          fctText, loge = FALSE)\n{\n  numParm <- 4\n  if (!is.character(names) | !(length(names) == numParm)) {\n    stop(\"Not correct 'names' argument\")\n  }\n  if (!(length(fixed) == numParm)) {\n    stop(\"Not correct 'fixed' argument\")\n  }\n  notFixed <- is.na(fixed)\n  parmVec <- rep(0, numParm)\n  parmVec[!notFixed] <- fixed[!notFixed]\n  if (!loge) {\n    fd <- function(dose, b, c, d, e) {\n      .expr1 <- d - c\n      .expr4 <- log10(dose) - log10(e)\n      .expr5 <- b * .expr4\n      .expr6 <- pnorm(.expr5)\n      .expr9 <- dnorm(.expr5)\n      .value <- c + .expr1 * .expr6\n      .grad <- array(0, c(length(.value), 4L), list(NULL,\n                                                    c(\"b\", \"c\", \"d\", \"e\")))\n      tempVec <- .expr9 * .expr4\n      tempVec[!is.finite(tempVec)] <- 0\n      .grad[, \"b\"] <- .expr1 * tempVec\n      .grad[, \"c\"] <- 1 - .expr6\n      .grad[, \"d\"] <- .expr6\n      .grad[, \"e\"] <- -(.expr1 * (.expr9 * (b * (1/e))))\n      attr(.value, \"gradient\") <- .grad\n      .value\n    }\n    transfe <- log10\n    backe <- function(x) 10^x\n  }\n  else {\n    fd <- function(dose, b, c, d, e) {\n      .expr1 <- d - c\n      .expr3 <- log10(dose) - e\n      .expr4 <- b * .expr3\n      .expr5 <- pnorm(.expr4)\n      .expr8 <- dnorm(.expr4)\n      .value <- c + .expr1 * .expr5\n      .grad <- array(0, c(length(.value), 4L), list(NULL, c(\"b\", \"c\", \"d\", \"e\")))\n      tempVec <- .expr8 * .expr3\n      tempVec[!is.finite(tempVec)] <- 0\n      .grad[, \"b\"] <- .expr1 * tempVec\n      .grad[, \"c\"] <- 1 - .expr5\n      .grad[, \"d\"] <- .expr5\n      .grad[, \"e\"] <- -(.expr1 * (.expr8 * b))\n      attr(.value, \"gradient\") <- .grad\n      .value\n    }\n    transfe <- function(x) {\n      x\n    }\n    backe <- function(x) {\n      x\n    }\n  }\n  fct <- function(dose, parm) {\n    parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n    parmMat[, notFixed] <- parm\n    fd(dose, parmMat[, 1], parmMat[, 2], parmMat[, 3], parmMat[,4])\n  }\n  if (!is.null(ssfct)) {\n    ssfct <- ssfct\n  }\n  else {\n    ssfct <- l10normal.ssf(method, fixed, loge)\n  }\n  names <- names[notFixed]\n  deriv1 <- function(dose, parm) {\n    parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n    parmMat[, notFixed] <- parm\n    attr(fd(dose, parmMat[, 1], parmMat[, 2], parmMat[, 3],\n            parmMat[, 4]), \"gradient\")[, notFixed]\n  }\n  deriv2 <- NULL\n  derivx <- function(dose, parm) {\n    parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n    parmMat[, notFixed] <- parm\n    dFct <- function(dose, b, c, d, e) {\n      .expr1 <- d - c\n      .expr5 <- b * (log10(dose) - transfe(e))\n      .value <- c + .expr1 * pnorm(.expr5)\n      .grad <- array(0, c(length(.value), 1L), list(NULL,c(\"dose\")))\n      .grad[, \"dose\"] <- .expr1 * (dnorm(.expr5) * (b *(1/dose)))\n      attr(.value, \"gradient\") <- .grad\n      .value\n    }\n    attr(dFct(dose, parmMat[, 1], parmMat[, 2], parmMat[,3], parmMat[, 4]), \"gradient\")\n  }\n  edfct <- function(parm, respl, reference, type, ...) {\n    parmVec[notFixed] <- parm\n    p <- absToRel(parmVec, respl, type)\n    if (identical(type, \"absolute\")) {\n      p <- 100 - p\n    }\n    if (identical(type, \"relative\") && (parmVec[1] < 0) &&\n        (reference == \"control\")) {\n      p <- 100 - p\n    }\n    pProp <- 1 - (100 - p)/100\n    if (!loge) {\n      EDfct <- function(b, c, d, e) {\n        .expr2 <- 10^(qnorm(pProp)/b)\n        .value <- e * .expr2\n        .grad <- array(0, c(length(.value), 4L), list(NULL, c(\"b\", \"c\", \"d\", \"e\")))\n        .grad[, \"b\"] <- -(e * (.expr2 * (qnorm(pProp)/(b^2))))\n        .grad[, \"c\"] <- 0\n        .grad[, \"d\"] <- 0\n        .grad[, \"e\"] <- .expr2\n        attr(.value, \"gradient\") <- .grad\n        .value\n      }\n    }\n    else {\n      EDfct <- function(b, c, d, e) {\n        .value <- e + qnorm(pProp)/b\n        .grad <- array(0, c(length(.value), 4L), list(NULL,c(\"b\", \"c\", \"d\", \"e\")))\n        .grad[, \"b\"] <- -(qnorm(pProp)/(b^2))\n        .grad[, \"c\"] <- 0\n        .grad[, \"d\"] <- 0\n        .grad[, \"e\"] <- 1\n        attr(.value, \"gradient\") <- .grad\n        .value\n      }\n    }\n    EDp <- EDfct(parmVec[1], parmVec[2], parmVec[3], parmVec[4])\n    EDder <- attr(EDfct(parmVec[1], parmVec[2], parmVec[3],\n                        parmVec[4]), \"gradient\")\n    return(list(EDp, EDder[notFixed]))\n  }\n  lowerAs <- pickParm(parmVec, notFixed, 2)\n  upperAs <- pickParm(parmVec, notFixed, 3)\n  monoton <- monoParm(parmVec, notFixed, 1, -1)\n  returnList <- list(fct = fct, ssfct = ssfct, names = names,\n                     deriv1 = deriv1, deriv2 = deriv2, derivx = derivx, edfct = edfct,\n                     name = ifelse(missing(fctName), as.character(match.call()[[1]]),\n                                   fctName), text = ifelse(missing(fctText), \"Log10-normal\",\n                                                           fctText), noParm = sum(is.na(fixed)),\n                     lowerAs = lowerAs,upperAs = upperAs, monoton = monoton, fixed = fixed)\n  class(returnList) <- \"log10-normal\"\n  invisible(returnList)\n}\n\nL10N.2 <- function (upper = 1, fixed = c(NA, NA), names = c(\"b\", \"e\"),\n          ...)\n{\n  numParm <- 2\n  if (!is.character(names) | !(length(names) == numParm)) {\n    stop(\"Not correct 'names' argument\")\n  }\n  if (!(length(fixed) == numParm)) {\n    stop(\"Not correct length of 'fixed' argument\")\n  }\n  return(l10normal(fixed = c(fixed[1], 0, upper, fixed[2]), names =\n                   c(names[1],\"c\", \"d\", names[2]), fctName = as.character(match.call()[[1]]),\n                 fctText = lowupFixed(\"Log10-normal\", upper), ...))\n}\n\n\"l10normal.ssf\" <- function(method = c(\"1\", \"2\", \"3\", \"4\"), fixed, loge, useFixed = FALSE)\n{\n  method <- match.arg(method)\n\n  ## Defining helper functions (used below)\n  ytrans <- function(y, cVal, dVal) {qnorm((y-cVal)/(dVal-cVal))}\n  bfct <- function(x, y, cVal, dVal, eVal) {ytrans(y, cVal, dVal)/log10(x/eVal)}\n  efct <- function(x, y, bVal, cVal, dVal) {x * 10^(-ytrans(y, cVal, dVal)/bVal)}\n\n  ## Assigning function for finding initial b and e parameter values\n  findbe <- switch(method,\n                   \"1\" = findbe1(function(x) {rVec <- log10(x); rVec[!x>0] <- NA; rVec},\n                                 function(y, cVal, dVal) {qnorm((dVal - y) / (1.01 * max(dVal - y)))}, -1),\n                   \"2\" = findbe2(bfct, efct, \"Anke\", -1),\n                   \"3\" = findbe3(-1),\n                   \"4\" = findbe2(bfct, efct, \"Normolle\", -1))\n\n  function(dframe)\n  {\n    x <- dframe[, 1]\n    y <- dframe[, 2]\n\n    ## Finding initial values for c and d parameters\n    cdVal <- findcd(x, y)\n    if (useFixed) {}  # not implemented at the moment\n\n    ## Finding initial values for b and e parameters\n    beVal <- findbe(x, y, cdVal[1], cdVal[2])\n    if (loge) {beVal[2] <- log10(beVal[2])}\n\n    return(c(beVal[1], cdVal, beVal[2])[is.na(fixed)])\n  }\n}\n\n\"DRCfpl\" <-\nfunction(fixed = c(NA, NA, NA, NA), names = c(\"c\", \"d\", \"mu\", \"sigma\"))\n{\n    ## Checking arguments\n    numParm <- 4\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        c <- parmMat[, 1]; d <- parmMat[, 2]; mu <- parmMat[, 3]; sigma <- parmMat[, 3]\n        c + (d - c) / (1 + exp((mu-x)/sigma))\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n\n        d <- max(y) * 1.05\n        c <- min(y) - 0.0001\n        ## Linear regression on pseudo y values\n        pseudoY <- log((d - y) / (y - c ))\n        coefs <- coef( lm(pseudoY ~ x) )\n        m <- - coefs[2]\n        mu <- coefs[1] / m\n        sigma <- 1/m\n\n        return(c(c, d, mu, sigma)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Logistic function (4 parms)\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"logLogisticD.2\" <-\nfunction(fixed = c(NA, NA), names = c(\"a\", \"b\"))\n{\n    ## Checking arguments\n    numParm <- 2\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        a <- parmMat[, 1]; b <- parmMat[, 2]\n        1 - (1 / (1 + exp(a + b*log(x))))\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- 1 - dataf[, 2] - 0.000001\n\n        ## Linear regression on pseudo y values\n        pseudoY <- log( y / (1-y ))\n        coefs <- coef( lm(pseudoY ~ x) )\n        b <- coefs[2]\n        a <- coefs[1]\n\n        return(c(a, b)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Traditional log-Logistic model\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"logLogisticD.3\" <-\nfunction(fixed = c(NA, NA, NA), names = c(\"plateau\",\"a\", \"b\"))\n{\n    ## Checking arguments\n    numParm <- 3\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        plateau <- parmMat[,1]; a <- parmMat[, 2]; b <- parmMat[, 3]\n        1 - (plateau / (1 + exp(a + b*log(x))))\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- 1 - dataf[, 2] + 0.000001\n\n        ## Linear regression on pseudo y values\n        plateau <- max(y) * 1.05\n\n        pseudoY <- log( y / (1-y))\n        coefs <- coef( lm(pseudoY ~ x) )\n        b <- coefs[2]\n        a <- coefs[1]\n\n        return(c(plateau, a, b)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Traditional log-Logistic model with upper asymptote\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"logLogistic.2\" <-\nfunction(fixed = c(NA, NA), names = c(\"a\", \"b\"))\n{\n    ## Checking arguments\n    numParm <- 2\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        a <- parmMat[, 1]; b <- parmMat[, 2]\n        1 / (1 + exp(-(a + b*log(x))))\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2] + 0.000001\n\n        ## Linear regression on pseudo y values\n        pseudoY <- log( y / (1-y) )\n        coefs <- coef( lm(pseudoY ~ x) )\n        b <- coefs[2]\n        a <- coefs[1]\n\n        return(c(a, b)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Traditional log-Logistic model\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"logLogistic.3\" <-\nfunction(fixed = c(NA, NA, NA), names = c(\"plateau\",\"a\", \"b\"))\n{\n    ## Checking arguments\n    numParm <- 3\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        plateau <- parmMat[,1]; a <- parmMat[, 2]; b <- parmMat[, 3]\n        plateau / (1 + exp(-(a + b*log(x))))\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2] + 0.000001\n\n        ## Linear regression on pseudo y values\n        plateau <- max(y) * 1.05\n\n        pseudoY <- log( y / (plateau - y) )\n        coefs <- coef( lm(pseudoY ~ x) )\n        b <- coefs[2]\n        a <- coefs[1]\n\n        return(c(plateau, a, b)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Traditional log-Logistic model with upper asymptote\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n",
    "created" : 1519310170153.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "433546049",
    "id" : "6ACD0754",
    "lastKnownWriteTime" : 1519310176,
    "last_content_update" : 1519310176776,
    "path" : "~/Documents/_DBXAndrea/Dropbox/_Lavoro/MyUtilities/RPackages/Functions/selfStartDRC_New.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}