{
    "collab_server" : "",
    "contents" : "\"linear\" <- function(fixed = c(NA, NA), names = c(\"a\", \"b\"))\n{\n    ## Checking arguments\n    numParm <- 2\n    if (!is.character(names) | !(length(names) == numParm))\n      {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm))\n      {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        a <- parmMat[, 1]; b <- parmMat[, 2]\n        a + b * x\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n\n        #regression on pseudo y values\n        pseudoY <- y\n        pseudoX <- x\n        coefs <- coef( lm(pseudoY ~ pseudoX) )\n        a <- coefs[1]\n\n        b <- coefs[2]\n\n        return(c(a, b)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Straight line\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"parabolic\" <- function(fixed = c(NA, NA, NA), names = c(\"a\", \"b\", \"c\"))\n{\n  ## Checking arguments\n  numParm <- 3\n  if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n  if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n  ## Fixing parameters (using argument 'fixed')\n  notFixed <- is.na(fixed)\n  parmVec <- rep(0, numParm)\n  parmVec[!notFixed] <- fixed[!notFixed]\n\n  ## Defining the non-linear function\n  fct <- function(x, parm)\n  {\n    parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n    parmMat[, notFixed] <- parm\n\n    a <- parmMat[, 1]; b <- parmMat[, 2]; c <- parmMat[, 3]\n    a + b * x + c * (x^2)\n  }\n\n  ## Defining self starter function\n  ssfct <- function(dataf)\n  {\n    x <- dataf[, 1]\n    y <- dataf[, 2]\n\n    #regression on pseudo y values\n    pseudoY <- y\n    pseudoX <- x\n    coefs <- coef( lm(pseudoY ~ pseudoX + I(pseudoX^2)) )\n    a <- coefs[1]\n    b <- coefs[2]\n    c <- coefs[3]\n\n    return(c(a, b, c)[notFixed])\n  }\n\n  ## Defining names\n  pnames <- names[notFixed]\n\n  ## Defining derivatives\n\n  ## Defining the ED function\n\n  ## Defining the inverse function\n\n  ## Defining descriptive text\n  text <- \"Second Order Polynomial\"\n\n  ## Returning the function with self starter and names\n  returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n  class(returnList) <- \"drcMean\"\n  invisible(returnList)\n}\n\n\"poly.3\" <- function(fixed = c(NA, NA, NA, NA), names = c(\"a\", \"b\", \"c\", \"d\"))\n{\n  ## Checking arguments\n  numParm <- 4\n  if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n  if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n  ## Fixing parameters (using argument 'fixed')\n  notFixed <- is.na(fixed)\n  parmVec <- rep(0, numParm)\n  parmVec[!notFixed] <- fixed[!notFixed]\n\n  ## Defining the non-linear function\n  fct <- function(x, parm)\n  {\n    parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n    parmMat[, notFixed] <- parm\n    a <- parmMat[, 1]; b <- parmMat[, 2]; c <- parmMat[, 3]; d <- parmMat[, 4]\n    a + b * x + c * (x^2) + d * (x^3)\n  }\n\n  ## Defining self starter function\n  ssfct <- function(dataf)\n  {\n    x <- dataf[, 1]\n    y <- dataf[, 2]\n\n    #regression on pseudo y values\n    pseudoY <- y\n    pseudoX <- x\n    coefs <- coef( lm(pseudoY ~ pseudoX + I(pseudoX^2) + I(pseudoX^3)) )\n    a <- coefs[1]\n    b <- coefs[2]\n    c <- coefs[3]\n    d <- coefs[4]\n\n    return(c(a, b, c, d)[notFixed])\n  }\n\n  ## Defining names\n  pnames <- names[notFixed]\n\n  ## Defining derivatives\n\n  ## Defining the ED function\n\n  ## Defining the inverse function\n\n  ## Defining descriptive text\n  text <- \"Third Order Polynomial\"\n\n  ## Returning the function with self starter and names\n  returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n  class(returnList) <- \"drcMean\"\n  invisible(returnList)\n}\n\n\"powerCurve\" <- function(fixed = c(NA, NA), names = c(\"a\", \"b\"))\n{\n    ## Checking arguments\n    numParm <- 2\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n\n\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        a <- parmMat[, 1]; b <- parmMat[, 2]\n        a * x ^(b)\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n\n        #regression on pseudo y values\n        pseudoY <- log( y + 0.00001)\n        pseudoX <- log(x)\n        coefs <- coef( lm(pseudoY ~ pseudoX) )\n        a <- exp(coefs[1])\n\n        b <- coefs[2]\n\n        return(c(a, b)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Power curve (Freundlich equation)\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"logCurve\" <-\nfunction(fixed = c(NA, NA), names = c(\"a\", \"b\"))\n{\n    ## Checking arguments\n    numParm <- 2\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n\n\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        a <- parmMat[, 1]; b <- parmMat[, 2]\n        a  + b * log(x)\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n\n        #regression on pseudo y values\n        pseudoY <-  y\n        pseudoX <- log(x)\n        coefs <- coef( lm(pseudoY ~ pseudoX) )\n        a <- coefs[1]\n        b <- coefs[2]\n\n        return(c(a, b)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Linear regression on log-transformed x\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"negExp\" <-\nfunction(fixed = c(NA, NA), names = c(\"a\", \"b\"))\n{\n    ## Checking arguments\n    numParm <- 2\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        a <- parmMat[, 1]; b <- parmMat[, 2]\n        a*(1 - exp (- b * x))\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n\n        plateau <- max(y) * 1.05\n\n        ## Linear regression on pseudo y values\n        pseudoY <- log( 1 - (y / plateau ) )\n        coefs <- coef( lm(pseudoY ~ x - 1) )\n        a <- plateau\n        b <- - coefs[1]\n\n        return(c(a, b)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Negative exponential model\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"asymReg\" <- function(fixed = c(NA, NA, NA), names = c(\"a\", \"b\", \"c\"))\n{\n    ## Checking arguments\n    numParm <- 3\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        a <- parmMat[, 1]; b <- parmMat[, 2]; c <- parmMat[, 3]\n        a - b*c ^ (- x)\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n\n        a <- max(y) * 1.05\n        b <- a - min(y) * 0.95\n\n        ## Linear regression on pseudo y values\n        pseudoY <- log( (a - y) / b )\n        coefs <- coef( lm(pseudoY ~ x - 1) )\n        c <- exp(coefs[1])\n\n        return(c(a, b, c)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Asymptotic regression\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\n\"extremeValue\" <-\nfunction(fixed = c(NA, NA, NA), names = c(\"b\", \"d\", \"e\"))\n{\n    ## Checking arguments\n    numParm <- 3\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        b <- parmMat[, 1]; d <- parmMat[, 2]; e <- parmMat[, 3]\n        d * (1 - exp(- exp(b * (x - e) )))\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n        d <- max(y) * 1.05\n\n        ## Linear regression on pseudo y values\n        y[y==0] <- 0.0000001\n        pseudoY <- log( - log (( d - y )/d ))\n        coefs <- coef( lm(pseudoY ~ x ) )\n        b <- coefs[2]\n        e <- - coefs[1] / b\n\n\n        return(c(b, d, e)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Extreme value function\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"hill\" <-\nfunction(fixed = c(NA, NA, NA), names = c(\"a\", \"b\", \"c\"))\n{\n    ## Checking arguments\n    numParm <- 3\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        a <- parmMat[, 1]; b <- parmMat[, 2]; c <- parmMat[, 3]\n        (a * x^c)/(b + x^c)\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n\n        a <- max(y) * 1.05\n\n        ## Linear regression on pseudo y values\n        pseudoY <-  log(( a - y )/ y)\n        pseudoX <- log(x)\n        coefs <- coef( lm(pseudoY ~ pseudoX ) )\n        b <- exp(coefs[1])\n        c <- - coefs[2]\n\n        return(c(a, b, c)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Hill function (Morgan-Mercer-Flodin)\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"hillMax\" <-\nfunction(fixed = c(NA, NA, NA), names = c(\"a\", \"b\", \"c\"))\n{\n    ## Checking arguments\n    numParm <- 3\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        a <- parmMat[, 1]; b <- parmMat[, 2]; c <- parmMat[, 3]\n        (8 * 0.8 * (1 + b * exp ( -c * log(a))))/(1 + b * exp ( -c * log(x)))\n    }\n\n    ## Defining self starter function\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining descriptive text\n    text <- \"Hill function (Morgan-Mercer-Flodin) with expected value parameters replacement\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\n\"chapman\" <-\nfunction(fixed = c(NA, NA, NA), names = c(\"a\", \"b\", \"c\"))\n{\n    ## Checking arguments\n    numParm <- 3\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        a <- parmMat[, 1]; b <- parmMat[, 2]; c <- parmMat[, 3]\n        a*(1-exp(-b*(x)))^c\n    }\n\n    ## Defining self starter function\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Chapman-Richard function\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"rational.1\" <-\nfunction(fixed = c(NA, NA, NA), names = c(\"a\", \"b\", \"c\"))\n{\n    ## Checking arguments\n    numParm <- 3\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        a <- parmMat[, 1]; b <- parmMat[, 2]; c <- parmMat[, 3]\n       (b + c*x)/(1 + a*x)\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n        xy <- dataf[,1]*dataf[,2]\n\n        ## Linear regression on pseudo y values\n\n        coefs <- coef(lm(y ~ x + xy) )\n        b <- coefs[1]\n        c <- coefs[2]\n        a <- - coefs[3]\n\n        return(c(a, b, c)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Inverse polynomial 1\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"rational.2\" <-\nfunction(fixed = c(NA, NA, NA, NA), names = c(\"a\", \"b\", \"c\", \"d\"))\n{\n    ## Checking arguments\n    numParm <- 4\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        a <- parmMat[, 1]; b <- parmMat[, 2]; c <- parmMat[, 3]; d <- parmMat[, 4]\n       (b + c*x)/(1 + a*x + d*x^2)\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n        xy <- dataf[,1]*dataf[,2]\n        x2 <- dataf[,1]^2\n\n        ## Linear regression on pseudo y values\n\n        coefs <- coef(lm(y ~ x + xy + x2) )\n        b <- coefs[1]\n        c <- coefs[2]\n        a <- - coefs[3]\n        d <- - coefs[4]\n\n        return(c(a, b, c, d)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Inverse polynomial 2\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"polyInv.2\" <-\nfunction(fixed = c(NA, NA, NA), names = c(\"a\", \"b\", \"c\"))\n{\n    ## Checking arguments\n    numParm <- 3\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        a <- parmMat[, 1]; b <- parmMat[, 2]; c <- parmMat[, 3]\n       1/(a + b*x + c*(x^2))\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n\n        ## Linear regression on pseudo y values\n\n        coefs <- coef(glm(y ~ x + I(x^2), family=gaussian(link=\"inverse\")))\n\n        a <- coefs[1]\n        b <- coefs[2]\n        c <- coefs[3]\n\n        return(c(a, b, c)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Inverse quadratic polynomial\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"hyperbolic\" <-\nfunction(fixed = c(NA, NA), names = c(\"a\", \"b\"))\n{\n    ## Checking arguments\n    numParm <- 2\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n\n\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        a <- parmMat[, 1]; b <- parmMat[, 2]\n        a * x / ( b + x )\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n\n        #regression on pseudo y values\n        pseudoY <- 1 /  (y + 0.000001)\n        pseudoX <- 1 / (x +0.00001)\n        coefs <- coef( lm(pseudoY ~ pseudoX) )\n        a <- 1 / exp(coefs[1]); b <- a * coefs[2]\n\n        return(c(a, b)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Rectangular hyperbola\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"allometric\" <-\nfunction(fixed = c(NA, NA), names = c(\"a\", \"b\"))\n{\n    ## Checking arguments\n    numParm <- 2\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n\n\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        a <- parmMat[, 1]; b <- parmMat[, 2]\n        a * x ^(-b)\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n\n        #regression on pseudo y values\n        pseudoY <- log( y )\n        pseudoX <- log(x)\n        coefs <- coef( lm(pseudoY ~ pseudoX) )\n        a <- exp(coefs[1]); b <- - coefs[2]\n\n        return(c(a, b)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Freundlich Equation (decreasing)\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"monoGrowth\" <-\nfunction(fixed = c(NA, NA, NA), names = c(\"init\", \"m\", \"plateau\"))\n{\n    ## Checking arguments\n    numParm <- 3\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        W0 <- parmMat[, 1]; Wf <- parmMat[, 3]; m <- parmMat[, 2]\n        Wf - (Wf - W0) * exp (- m * x)\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n\n        plateau <- max(y) * 1.05\n\n        ## Linear regression on pseudo y values\n        pseudoY <- log( 1 - (y / plateau ) )\n        coefs <- coef( lm(pseudoY ~ x) )\n        b <- exp(coefs[1])\n        init <- plateau * (1 - b)\n        m <- - coefs[2]\n\n        return(c(init, m, plateau)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Monomolecular Growth Model\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"gompGrowth.1\" <-\nfunction(fixed = c(NA, NA, NA), names = c(\"c\", \"m\", \"plateau\"))\n{\n    ## Checking arguments\n    numParm <- 3\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n\n\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        c <- parmMat[, 1]; m <- parmMat[, 2]; a <- parmMat[, 3]\n        a * exp( - (m/c) * exp (-c * x))\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n\n        plateau <- max(y) * 1.05\n\n        ## Linear regression on pseudo y values\n        pseudoY <- log( - log( y / plateau ) )\n        coefs <- coef( lm(pseudoY ~ x) )\n        k <- coefs[1]; c <- - coefs[2]\n        b <- exp(k)\n        m <- b * c\n\t      return(c(c, m, plateau)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Gompertz Growth Model - 1\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"gompGrowth.2\" <-\nfunction(fixed = c(NA, NA, NA), names = c(\"c\", \"d\", \"plateau\"))\n{\n    ## Checking arguments\n    numParm <- 3\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n\n\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        a <- parmMat[, 3]; b <- parmMat[, 1]; c <- parmMat[, 2]\n        a * exp( - exp (b * (c - x)))\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n\n        a <- max(y) * 1.05\n\n        ## Linear regression on pseudo y values\n        pseudoY <- log( log( a / (y +0.0001) ) )\n        coefs <- coef( lm(pseudoY ~ x) )\n\n        k <- coefs[1]\n        b <- - coefs[2]\n        c <- k/b\n\n        return(c(b, c, a)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Gompertz Growth Model - 2\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"gompGrowth.3\" <-\nfunction(fixed = c(NA, NA, NA), names = c(\"b\", \"c\", \"plateau\"))\n{\n    ## Checking arguments\n    numParm <- 3\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n\n\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        a <- parmMat[, 3]; b <- parmMat[, 1]; c <- parmMat[, 2]\n        a * exp( - b * exp (-c * x))\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n\n        a <- max(y) * 1.05\n\n        ## Linear regression on pseudo y values\n        pseudoY <- log( - log( y / a ) )\n        coefs <- coef( lm(pseudoY ~ x) )\n\n        k <- coefs[1]\n        c <- - coefs[2]\n        b <- exp(k)\n\n        return(c(b, c, a)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Gompertz Growth Model - 3\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"expoGrowth\" <-\nfunction(fixed = c(NA, NA), names = c(\"init\", \"m\"))\n{\n    ## Checking arguments\n    numParm <- 2\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        W0 <- parmMat[, 1]; m <- parmMat[, 2]\n        W0 * exp ( m * x )\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n\n        ## Linear regression on pseudo y values\n        pseudoY <- log( y + 0.000001)\n        coefs <- coef( lm(pseudoY ~ x) )\n        init <- exp(coefs[1])\n        m <- coefs[2]\n\n        return(c(init, m)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Exponential Growth Model\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"expoGrowth.2\" <-\n  function(fixed = c(NA, NA,NA), names = c(\"init\", \"m\", \"base\"))\n  {\n    ## Checking arguments\n    numParm <- 3\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n      parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n      parmMat[, notFixed] <- parm\n\n      W0 <- parmMat[, 1]; m <- parmMat[, 2]; base <- parmMat[, 3]\n      base + W0 * exp ( m * x )\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n      x <- dataf[, 1]\n      y <- dataf[, 2]\n\n      ## Linear regression on pseudo y values\n      base <- min(y)\n      pseudoY <- log( y + 0.000001 - base)\n      coefs <- coef( lm(pseudoY ~ x) )\n      init <- exp(coefs[1])\n      m <- coefs[2]\n\n\n      return(c(init, m, base)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Exponential Growth Model with baseline\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n  }\n\n\"firstOrder\" <-\nfunction(fixed = c(NA, NA), names = c(\"init\", \"k\"))\n{\n    ## Checking arguments\n    numParm <- 2\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n        parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n        parmMat[, notFixed] <- parm\n\n        init <- parmMat[, 1]; k <- parmMat[, 2]\n        init * exp ( - k * x )\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n        x <- dataf[, 1]\n        y <- dataf[, 2]\n\n        ## Linear regression on pseudo y values\n        pseudoY <- log( y + 0.000001)\n        coefs <- coef( lm(pseudoY ~ x) )\n        init <- exp(coefs[1])\n        m <- - coefs[2]\n\n        return(c(init, m)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Exponential Decay Model\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n}\n\n\"firstOrder.2\" <-\n  function(fixed = c(NA, NA, NA), names = c(\"init\", \"k\", \"base\"))\n  {\n    ## Checking arguments\n    numParm <- 3\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n      parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n      parmMat[, notFixed] <- parm\n\n      init <- parmMat[, 1]; k <- parmMat[, 2]; base <- parmMat[, 3]\n      base + init * exp ( - k * x )\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n      x <- dataf[, 1]\n      y <- dataf[, 2]\n\n      ## Linear regression on pseudo y values\n      pseudoY <- log( y + 0.000001)\n      coefs <- coef( lm(pseudoY ~ x) )\n      init <- exp(coefs[1])\n      m <- - coefs[2]\n      base <- min(y)\n\n      return(c(init, m, base)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Exponential Decay Model with baseline value\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n  }\n\n\"truncGauss\" <-\n  function(fixed = c(NA, NA, NA), names = c(\"mu\", \"sigma\", \"Pmax\"))\n  {\n    ## Checking arguments\n    numParm <- 3\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n      parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n      parmMat[, notFixed] <- parm\n\n      mu <- parmMat[, 1]; sigma <- parmMat[, 2]; Pmax <- parmMat[, 3]\n      pnorm(x, mu, sigma) * Pmax\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n      x <- dataf[, 1]\n      y <- dataf[, 2]\n\n      ## Linear regression on pseudo y values\n      Pmax <- max(y)\n      mu <- mean(x)\n      sigma <- sd(x)\n\n\n      return(c(mu, sigma, Pmax)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Truncated Cumulative normal distribution\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n  }\n\n\"gaussian\" <-\n  function(fixed = c(NA, NA), names = c(\"mu\", \"sigma\"))\n  {\n    ## Checking arguments\n    numParm <- 2\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n      parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n      parmMat[, notFixed] <- parm\n\n      mu <- parmMat[, 1]; sigma <- parmMat[, 2]\n      pnorm(x, mu, sigma)\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n      x <- dataf[, 1]\n      y <- dataf[, 2]\n\n      ## Linear regression on pseudo y values\n      pseudoY <- qnorm(y+0.0001)\n      coefs <- coef( lm(pseudoY ~ x))\n      b <- coefs[1]; k <- coefs[2]\n      sigma <- 1/k\n      mu <- -b*sigma\n\n      return(c(mu, sigma)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Cumulative normal distribution\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n  }\n\n\"cousens85\" <-\n  function(fixed = c(NA, NA, NA), names = c(\"YWF\", \"i\", \"a\"))\n  {\n    ## Checking arguments\n    numParm <- 3\n    if (!is.character(names) | !(length(names) == numParm)) {stop(\"Not correct 'names' argument\")}\n    if (!(length(fixed) == numParm)) {stop(\"Not correct 'fixed' argument\")}\n\n    ## Fixing parameters (using argument 'fixed')\n    notFixed <- is.na(fixed)\n    parmVec <- rep(0, numParm)\n    parmVec[!notFixed] <- fixed[!notFixed]\n\n    ## Defining the non-linear function\n    fct <- function(x, parm)\n    {\n      parmMat <- matrix(parmVec, nrow(parm), numParm, byrow = TRUE)\n      parmMat[, notFixed] <- parm\n\n      YWF <- parmMat[, 1]; i <- parmMat[, 2]; a <- parmMat[, 3]\n      YWF*(1 - (i*x) / (100 * (1 + i * x/a)))\n    }\n\n    ## Defining self starter function\n    ssfct <- function(dataf)\n    {\n      x <- dataf[, 1]\n      y <- dataf[, 2]\n\n      YWF <- max(y) * 1.05\n      YL <- 1 - y/YWF * 100\n      #regression on pseudo y values\n      pseudoY <- 1 /  (YL + 0.000001)\n      pseudoX <- 1 / (x + 0.00001)\n      coefs <- coef( lm(pseudoY ~ pseudoX) )\n      a <- 1 / coefs[1]; i <- 1 / coefs[2]\n\n      return(c(YWF, i, a)[notFixed])\n    }\n\n    ## Defining names\n    pnames <- names[notFixed]\n\n    ## Defining derivatives\n\n    ## Defining the ED function\n\n    ## Defining the inverse function\n\n    ## Defining descriptive text\n    text <- \"Yield-Weed Density function (Cousens, 1985)\"\n\n    ## Returning the function with self starter and names\n    returnList <- list(fct = fct, ssfct = ssfct, names = pnames, text = text, noParm = sum(is.na(fixed)))\n\n    class(returnList) <- \"drcMean\"\n    invisible(returnList)\n  }\n\n\n",
    "created" : 1519309639434.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3428609239",
    "id" : "99156EF1",
    "lastKnownWriteTime" : 1519310048,
    "last_content_update" : 1519310048106,
    "path" : "~/Documents/_DBXAndrea/Dropbox/_Lavoro/MyUtilities/RPackages/statBook/R/SelfStartDrc.r",
    "project_path" : "R/SelfStartDrc.r",
    "properties" : {
        "docOutlineSize" : "143.99899330366298",
        "docOutlineVisible" : "1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}